{
  "hash": "9221e27682568c8f5443ebb50afc89b1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Simulating Power in within-subject psycholinguistic experiments using unstandardized measures of effect size\"\nauthor: \"Diogo Almeida & Roberto Petrosino\"\n\nexecute:\n  eval: false\n  \nformat: \n  html:\n    code-fold: true\n---\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nlibrary(ggplot2)\nlibrary(MASS)\n\n# --- Utility Functions --- #\n\ninvert_argument_docall <- function(func){\n  function(data){\n    do.call(func, data)\n  }\n} \n\nrbind_list <- invert_argument_docall(rbind)\n\nmatcols2lists <- function(data_matrix, group_by = 2) {\n  ncols <- ncol(data_matrix)\n  stopifnot(!(ncols%%group_by))\n  start_indices <- seq(from = 1, to = ncols, by = group_by)\n  n_conditions <- length(start_indices)\n  grouped_conditions <- vector(mode = \"list\", length = n_conditions)\n  for (first_item in start_indices) {\n    grouped_conditions[[which(start_indices == first_item)]] <- data_matrix[, seq(first_item, first_item + group_by - 1)]\n  }\n  grouped_conditions\n}\n\norganize_output <- function(simdata_list) {\n  step_1 <- lapply(simdata_list, FUN = t)\n  n_conds <- ncol(step_1[[1]])\n  n_measures <- nrow(step_1[[1]])\n  measure_labels <- rownames(step_1[[1]])\n  c_lbl <- paste0(\"cond\", rep(1:n_conds, each = n_measures), \"_\", rep(measure_labels, n_conds))\n  step_2 <- step_1 |>\n    rapply(as.vector, how = \"list\") |>\n    rbind_list()\n  colnames(step_2) <- c_lbl\n  step_2 |>\n    matcols2lists(group_by = n_measures)\n}\n\ncombine_sims <- function(sim_list) {\n  n_conds <- nrow(sim_list[[1]])\n  n_sims <- length(sim_list)\n  sim_df <- rbind_list(sim_list)\n  sim_df[[\"simulation\"]]  <- paste0(\"simulation_\", rep(1:n_sims, each = n_conds))\n  sim_df[[\"condition\"]] <- paste0(\"condition_\", rep(1:n_conds, times = n_sims))\n  sim_df\n}\n\n# --- Statistical Functions --- # \n\ncorrelation2covariance <- function(cor_mat, sd_var = 50) {\n  sweep(sweep(cor_mat, 1L, sd_var, \"*\"), 2L, sd_var, \"*\")  \n}\n\ncalc_cov_mat <- function(rho, std_dev, ncond = 2) {\n  corr_matrix <- matrix(rep(rho, times = ncond^2), ncol = ncond)\n  diag(corr_matrix) <- 1\n  cov_matrix <- correlation2covariance(cor_mat = corr_matrix, sd_var = std_dev)\n  cov_matrix\n}\n\nfast_t <- function(data_matrix) {\n  diff <- data_matrix[, 1] - data_matrix[, 2]\n  n <- length(diff)\n  deg_fre <- n - 1\n  sd_diff <- sd(diff)\n  se_diff <- sd_diff / sqrt(n)\n  mean_diff <- mean(diff)\n  t_val <- mean_diff / se_diff\n  t_crit <- qt(.975, df = deg_fre)\n  conf.int <- c(mean_diff - (t_crit * se_diff), mean_diff + (t_crit * se_diff))\n  p_val <- pt(-abs(t_val), df = deg_fre, lower.tail = TRUE) * 2 # change this for one-tail\n  list(statistic = t_val, parameter = deg_fre, p.value = p_val, conf.int = conf.int, \n       estimate = mean_diff, stderr = se_diff)\n}\n\nt_test_paired_data <- function(paired_data, fast = TRUE, use_names = TRUE,\n                               info_out = c(\"estimate\", \"statistic\", \"p.value\")) {\n  if (fast) {\n    test_result <- fast_t(paired_data)[info_out] |>\n      unlist()\n  } else {\n    test_result <- t.test(paired_data[, 1], paired_data[, 2], paired = TRUE)[info_out] |>\n      unlist()\n  }\n  if(use_names) {\n    true_means <- as.numeric(sub(\"C[0-9]+_\", \"\", colnames(paired_data)))\n    true_es <- true_means[1] - true_means[2]\n    test_result <- c(true_es, test_result)\n  } else {\n    test_result <- c(NA, test_result)\n  }\n  names(test_result) <- c(\"true_es\", \"estimate\", \"statistic\", \"p.value\")\n  test_result\n}\n\ntest_2x2_paired_data <- function(sim_results,rename_cols = TRUE) {\n  main1 <- t_test_paired_data(sim_results[, 1:2])\n  main2 <- t_test_paired_data(sim_results[, 3:4])\n  diff1 <- sim_results[, 1] - sim_results[, 2]\n  diff2 <- sim_results[, 3] - sim_results[, 4]\n  diff_diff <- cbind(diff1, diff2)\n  diff_es <- c(main1[\"true_es\"], main2[\"true_es\"])\n  colnames(diff_diff) <- paste0(\"C\", seq(diff_es), \"_\", diff_es)\n  interaction <- t_test_paired_data(diff_diff)\n  output <-  rbind(main1, main2, interaction) |>\n    transform(p.adjust = p.adjust(p.value, \"holm\"))\n  output[[\"condition\"]] <- rownames(output)\n  output\n}\n\ncalc_error_design <- function(sim_results, alpha = .05, rename_cols = TRUE) {\n  stopifnot(rename_cols)\n  col_labels <- colnames(sim_results)\n  colnames(sim_results) <- sub(\"cond[0-9]+_\", \"\", col_labels)\n\n  sig_subset_unadjusted <- subset(as.data.frame(sim_results), p.value < alpha)\n  sig_subset_adjusted <- subset(as.data.frame(sim_results), p.adjust < alpha)\n  sim_true_es <- mean(sig_subset_unadjusted$true_es)\n  nsim <- nrow(sim_results)\n  nsig_unadjusted <- nrow(sig_subset_unadjusted)\n  nsig_adjusted <- nrow(sig_subset_adjusted)\n  power_unadjusted <- nsig_unadjusted / nsim\n  power_adjusted <- nsig_adjusted / nsim\n  type_s_unadjusted <- nrow(subset(sig_subset_unadjusted, estimate < 0)) / nsig_unadjusted\n  type_s_adjusted <- nrow(subset(sig_subset_adjusted, estimate < 0)) / nsig_adjusted\n  exaggeration_ratio_unadjusted <- with(sig_subset_unadjusted, \n                                        mean(abs(estimate)) / mean(true_es))\n  exaggeration_ratio_adjusted <- with(sig_subset_adjusted, \n                                      mean(abs(estimate)) / mean(true_es))\n  errors <- c(ES = sim_true_es,\n              power_unadjusted = power_unadjusted,\n              type_s_unadjusted = type_s_unadjusted,\n              exaggeration_ratio_unadjusted = exaggeration_ratio_unadjusted,\n              power_adjusted = power_adjusted,\n              type_s_adjusted = type_s_adjusted,\n              exaggeration_ratio_adjusted = exaggeration_ratio_adjusted)\n  errors\n}\n\n# --- Simulation Functions --- #\n\nsimulate_data_from_es <- function(es, base_mu = 600) {\n  function(rho, std_dev, nsubj) {\n    condition_means <- as.vector(es + base_mu)\n    list(rho, std_dev)\n    cov_mat <- calc_cov_mat(rho, std_dev, ncond = length(es))  # one rho all conds\n    #cov_mat\n    simulation <- MASS::mvrnorm(n = nsubj, mu = condition_means, Sigma = cov_mat,\n                                empirical = FALSE)\n    colnames(simulation) <- paste0(\"C\", seq(condition_means), \"_\", condition_means)\n    simulation\n  }\n}\n\ndo_sim <- function(sim_params, sim_func, Nsim = 5000, alpha = 0.05){\n  replicate(Nsim, do.call(sim_func, sim_params), simplify = FALSE) |>\n    lapply(FUN = matcols2lists, group_by = 2) |>\n    rapply(t_test_paired_data, how = \"list\") |>\n    lapply(FUN = rbind_list) |>\n    lapply(FUN = transform, p.adjust = p.adjust(p.value, \"holm\")) |>\n    organize_output() |>\n    lapply(FUN = calc_error_design, alpha = alpha) |>\n    rbind_list() |>\n    data.frame(sim_params)\n}\n\ndo_sim_2x2 <- function(sim_params, sim_func, Nsim = 5000, alpha = 0.05) {\n  replicate(Nsim, do.call(sim_func, sim_params), simplify = FALSE) |>\n    lapply(FUN = matcols2lists, group_by = 4) |>\n    rapply(test_2x2_paired_data, how = \"list\" )  |>\n    unlist(recursive = FALSE) |>\n    rbind_list() |>\n    split(~condition) |>\n    lapply(FUN = calc_error_design, alpha = alpha) |>\n    rbind_list() |>\n    data.frame(sim_params)\n}\n```\n:::\n\n\n\n## Simulating possible scenarios for the Frequency Attenuation effect in Masked Priming\n\nSeventeen studies were found in the literature about frequency attenuation. Out of these:\n\n-   All show the repetition effect for both HF and LF words\n\n-   Only three show a statistically significant interaction between identity priming and frequency (with lower frequency words showing more masked id priming). The effect sizes on these three are quite large (30, 31 and 32 ms), about as large as the corresponding masked id priming for HF in the experiment\n\n- Overall:\n  -   The average attenuation effect numerically observed is 13 ms\n  -   The range of sample sizes is \\[16, 48\\]\n  -   The range of SD for HF is \\[55, 146\\]\n  -   The range of SD for LF is \\[60, 177\\]\n\nThus it seems reasonable that there may be a frequency attenuation effect, but what is its size? The experiments that detected it found a very large one, but these are rare. If the effect size really is that large, why aren't we finding the interaction as often as the main effects? Maybe the 30 ms range is an exaggeration, due to low power? Perhaps the most likely scenario is a 10-15 ms effect that can only be detected with sample sizes \\<= 48 when it is exaggerated.\n\nSo we will investigate three different interactions ESs: 5, 10, and 15 ms, across all combinations of:\n\n  -   sample size, between 200 and 3000 participants (with 150-participant increments)\n  -   standard deviation, between 60 and 110 ms (with 10 ms increments)\n  -   correlation between related and unrelated primetype conditions, ranging between 0.7 and 0.9 (with 0.1 increments)\n  \n### ES = 5 ms\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| cache: true\n\n## Simulation of simple effects: Using a matrix of possible parameters\nfreq_atten_exp2.5ms_Nsim <- 10000\n\n# ---- range of Effect Sizes ------#\n# ---- range of DD Effect Sizes ------#\nfreq_atten_exp2.5ms_base_es <- 60\nfreq_atten_exp2.5ms_dd_to_sim <- freq_atten_exp2.5ms_base_es - c(30, 25) # this will create the 2x2 design in which each pair will represent the unrelated and related level of each condition (e.g., high and low frequency). So the two values in the second term of the difference are the actual priming effects of the two conditions of the 2x2 factorial design. These priming effects will be analyzed in a paired t-test in each of the 10,000 simulations of each combination of sample size, sd, and rho. \n\n# ---- design ----#\nfreq_atten_exp2.5ms_design <- expand.grid(freq_atten_exp2.5ms_base_es, freq_atten_exp2.5ms_dd_to_sim) |>\n  t() |>\n  as.vector() |>\n  setNames(paste0(\"ES\", 1:(length(freq_atten_exp2.5ms_dd_to_sim)*2)))\n\n# ---- range of N ------#\nfreq_atten_exp2.5ms_n_subjs_to_sim <- seq(200, 3000, by = 150)\n\n# ---- range of SDs ------#\nfreq_atten_exp2.5ms_min_sd <- 60\nfreq_atten_exp2.5ms_max_sd <- 180\nfreq_atten_exp2.5ms_sd_increment <- 10\nfreq_atten_exp2.5ms_sds_to_sim <- seq(from = freq_atten_exp2.5ms_min_sd, to = freq_atten_exp2.5ms_max_sd, \n                                by = freq_atten_exp2.5ms_sd_increment)\n\n# ---- range of rhos ------#\nfreq_atten_exp2.5ms_min_rho <- .6\nfreq_atten_exp2.5ms_max_rho <- .9\nfreq_atten_exp2.5ms_rho_increment <- .1\nfreq_atten_exp2.5ms_rhos_to_sim <- seq(from = freq_atten_exp2.5ms_min_rho, to = freq_atten_exp2.5ms_max_rho, \n                                 by = freq_atten_exp2.5ms_rho_increment)\n\n# ---- create the control matrix ---- #\nfreq_atten_exp2.5ms_simulation_params <- expand.grid(freq_atten_exp2.5ms_rhos_to_sim,\n                                               freq_atten_exp2.5ms_sds_to_sim,\n                                               freq_atten_exp2.5ms_n_subjs_to_sim)\ncolnames(freq_atten_exp2.5ms_simulation_params) <- c(\"rho\", \"std_dev\", \"nsubj\")\nfreq_atten_exp2.5ms_simulate_effects <- simulate_data_from_es(freq_atten_exp2.5ms_design)\nfreq_atten_exp2.5ms_params <- freq_atten_exp2.5ms_simulation_params |>\n  split(seq(nrow(freq_atten_exp2.5ms_simulation_params))) |>\n  lapply(FUN = as.list)\n\n### Run simulation\nset.seed(20140715)\nt0 <- Sys.time()\nfreq_atten_exp2.5ms_df <- lapply(freq_atten_exp2.5ms_params, do_sim_2x2, \n                               freq_atten_exp2.5ms_simulate_effects, \n                               Nsim = freq_atten_exp2.5ms_Nsim) |>\n  combine_sims()\nSys.time() - t0\nsave(\"freq_atten_exp2.5ms_df\", file = \"freq_atten_exp2.5ms.RData\", compress=TRUE)\n\nload(\"freq_atten_exp2.5ms.RData\")\n\n## Plotting\nfreq_atten_exp2.5ms_df |>\n  subset(ES == 5) |>\n  ggplot(aes(x = nsubj, y = power_unadjusted)) + \n    geom_line(aes()) + \n    geom_point() +\n    geom_hline(yintercept = c(0.8, 0.5, 0.1), color = \"red2\") + \n    facet_grid(rho ~ std_dev) \n```\n:::\n\n\n\n### ES = 10 ms\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| cache: true\n\n## Simulation of simple effects: Using a matrix of possible parameters\nfreq_atten_exp2.10ms_Nsim <- 10000\n\n# ---- range of Effect Sizes ------#\n# ---- range of DD Effect Sizes ------#\nfreq_atten_exp2.10ms_base_es <- 60\nfreq_atten_exp2.10ms_dd_to_sim <- freq_atten_exp2.10ms_base_es - c(30, 20) # this will create the 2x2 design in which each pair will represent the unrelated and related level of each condition (e.g., high and low frequency). So the two values in the second term of the difference are the actual priming effects of the two conditions of the 2x2 factorial design. These priming effects will be analyzed in a paired t-test in each of the 10,000 simulations of each combination of sample size, sd, and rho. \n\n# ---- design ----#\nfreq_atten_exp2.10ms_design <- expand.grid(freq_atten_exp2.10ms_base_es, freq_atten_exp2.10ms_dd_to_sim) |>\n  t() |>\n  as.vector() |>\n  setNames(paste0(\"ES\", 1:(length(freq_atten_exp2.10ms_dd_to_sim)*2)))\n\n# ---- range of N ------#\nfreq_atten_exp2.10ms_n_subjs_to_sim <- seq(200, 3000, by = 150)\n\n# ---- range of SDs ------#\nfreq_atten_exp2.10ms_min_sd <- 60\nfreq_atten_exp2.10ms_max_sd <- 180\nfreq_atten_exp2.10ms_sd_increment <- 10\nfreq_atten_exp2.10ms_sds_to_sim <- seq(from = freq_atten_exp2.10ms_min_sd, to = freq_atten_exp2.10ms_max_sd, \n                                by = freq_atten_exp2.10ms_sd_increment)\n\n# ---- range of rhos ------#\nfreq_atten_exp2.10ms_min_rho <- .6\nfreq_atten_exp2.10ms_max_rho <- .9\nfreq_atten_exp2.10ms_rho_increment <- .1\nfreq_atten_exp2.10ms_rhos_to_sim <- seq(from = freq_atten_exp2.10ms_min_rho, to = freq_atten_exp2.10ms_max_rho, \n                                 by = freq_atten_exp2.10ms_rho_increment)\n\n# ---- create the control matrix ---- #\nfreq_atten_exp2.10ms_simulation_params <- expand.grid(freq_atten_exp2.10ms_rhos_to_sim,\n                                               freq_atten_exp2.10ms_sds_to_sim,\n                                               freq_atten_exp2.10ms_n_subjs_to_sim)\ncolnames(freq_atten_exp2.10ms_simulation_params) <- c(\"rho\", \"std_dev\", \"nsubj\")\nfreq_atten_exp2.10ms_simulate_effects <- simulate_data_from_es(freq_atten_exp2.10ms_design)\nfreq_atten_exp2.10ms_params <- freq_atten_exp2.10ms_simulation_params |>\n  split(seq(nrow(freq_atten_exp2.10ms_simulation_params))) |>\n  lapply(FUN = as.list)\n\n### Run simulation\nset.seed(20140715)\nt0 <- Sys.time()\nfreq_atten_exp2.10ms_df <- lapply(freq_atten_exp2.10ms_params, do_sim_2x2, \n                               freq_atten_exp2.10ms_simulate_effects, \n                               Nsim = freq_atten_exp2.10ms_Nsim) |>\n  combine_sims()\nSys.time() - t0\nsave(\"freq_atten_exp2.10ms_df\", file = \"freq_atten_exp2.10ms.RData\", compress=TRUE)\n\n\nload(\"freq_atten_exp2.10ms.RData\")\n\n## Plotting\nfreq_atten_exp2.10ms_df |>\n  subset(ES == 10) |>\n  ggplot(aes(x = nsubj, y = power_unadjusted)) + \n    geom_line(aes()) + \n    geom_point() +\n    geom_hline(yintercept = c(0.8, 0.5, 0.1), color = \"red2\") + \n    facet_grid(rho ~ std_dev) \n```\n:::\n\n\n\n### ES = 15 ms\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| cache: true\n\n## Simulation of simple effects: Using a matrix of possible parameters\nfreq_atten_exp2.15ms_Nsim <- 10000\n\n# ---- range of Effect Sizes ------#\n# ---- range of DD Effect Sizes ------#\nfreq_atten_exp2.15ms_base_es <- 60\nfreq_atten_exp2.15ms_dd_to_sim <- freq_atten_exp2.15ms_base_es - c(30, 15) # this will create the 2x2 design in which each pair will represent the unrelated and related level of each condition (e.g., high and low frequency). So the two values in the second term of the difference are the actual priming effects of the two conditions of the 2x2 factorial design. These priming effects will be analyzed in a paired t-test in each of the 10,000 simulations of each combination of sample size, sd, and rho. \n\n# ---- design ----#\nfreq_atten_exp2.15ms_design <- expand.grid(freq_atten_exp2.15ms_base_es, freq_atten_exp2.15ms_dd_to_sim) |>\n  t() |>\n  as.vector() |>\n  setNames(paste0(\"ES\", 1:(length(freq_atten_exp2.15ms_dd_to_sim)*2)))\n\n# ---- range of N ------#\nfreq_atten_exp2.15ms_n_subjs_to_sim <- seq(200, 3000, by = 150)\n\n# ---- range of SDs ------#\nfreq_atten_exp2.15ms_min_sd <- 60\nfreq_atten_exp2.15ms_max_sd <- 180\nfreq_atten_exp2.15ms_sd_increment <- 10\nfreq_atten_exp2.15ms_sds_to_sim <- seq(from = freq_atten_exp2.15ms_min_sd, to = freq_atten_exp2.15ms_max_sd, \n                                by = freq_atten_exp2.15ms_sd_increment)\n\n# ---- range of rhos ------#\nfreq_atten_exp2.15ms_min_rho <- .6\nfreq_atten_exp2.15ms_max_rho <- .9\nfreq_atten_exp2.15ms_rho_increment <- .1\nfreq_atten_exp2.15ms_rhos_to_sim <- seq(from = freq_atten_exp2.15ms_min_rho, to = freq_atten_exp2.15ms_max_rho, \n                                 by = freq_atten_exp2.15ms_rho_increment)\n\n# ---- create the control matrix ---- #\nfreq_atten_exp2.15ms_simulation_params <- expand.grid(freq_atten_exp2.15ms_rhos_to_sim,\n                                               freq_atten_exp2.15ms_sds_to_sim,\n                                               freq_atten_exp2.15ms_n_subjs_to_sim)\ncolnames(freq_atten_exp2.15ms_simulation_params) <- c(\"rho\", \"std_dev\", \"nsubj\")\nfreq_atten_exp2.15ms_simulate_effects <- simulate_data_from_es(freq_atten_exp2.15ms_design)\nfreq_atten_exp2.15ms_params <- freq_atten_exp2.15ms_simulation_params |>\n  split(seq(nrow(freq_atten_exp2.15ms_simulation_params))) |>\n  lapply(FUN = as.list)\n\n### Run simulation\nset.seed(20140715)\nt0 <- Sys.time()\nfreq_atten_exp2.15ms_df <- lapply(freq_atten_exp2.15ms_params, do_sim_2x2, \n                               freq_atten_exp2.15ms_simulate_effects, \n                               Nsim = freq_atten_exp2.15ms_Nsim) |>\n  combine_sims()\nSys.time() - t0\nsave(\"freq_atten_exp2.15ms_df\", file = \"freq_atten_exp2.15ms.RData\", compress=TRUE)\n\n\nload(\"freq_atten_exp2.15ms.RData\")\n\n## Plotting\nfreq_atten_exp2.15ms_df |>\n  subset(ES == 15) |>\n  ggplot(aes(x = nsubj, y = power_unadjusted)) + \n    geom_line(aes()) + \n    geom_point() +\n    geom_hline(yintercept = c(0.8, 0.5, 0.1), color = \"red2\") + \n    facet_grid(rho ~ std_dev) \n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}