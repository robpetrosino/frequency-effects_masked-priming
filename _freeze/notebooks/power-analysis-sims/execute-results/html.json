{
  "hash": "386430a1d43da85e81dd8df778f8efde",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Script E: Simulating Power in within-subject psycholinguistic experiments using unstandardized measures of effect size\"\nauthor: \"Diogo Almeida & Roberto Petrosino\"\n\nformat: \n  html:\n    code-fold: true\n---\n\n\n\n\n# Functions used in the calculations \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| eval: false\nlibrary(ggplot2)\nlibrary(MASS)\n\n# --- Utility Functions --- #\n\ninvert_argument_docall <- function(func){\n  function(data){\n    do.call(func, data)\n  }\n} \n\nrbind_list <- invert_argument_docall(rbind)\n\nmatcols2lists <- function(data_matrix, group_by = 2) {\n  ncols <- ncol(data_matrix)\n  stopifnot(!(ncols%%group_by))\n  start_indices <- seq(from = 1, to = ncols, by = group_by)\n  n_conditions <- length(start_indices)\n  grouped_conditions <- vector(mode = \"list\", length = n_conditions)\n  for (first_item in start_indices) {\n    grouped_conditions[[which(start_indices == first_item)]] <- data_matrix[, seq(first_item, first_item + group_by - 1)]\n  }\n  grouped_conditions\n}\n\norganize_output <- function(simdata_list) {\n  step_1 <- lapply(simdata_list, FUN = t)\n  n_conds <- ncol(step_1[[1]])\n  n_measures <- nrow(step_1[[1]])\n  measure_labels <- rownames(step_1[[1]])\n  c_lbl <- paste0(\"cond\", rep(1:n_conds, each = n_measures), \"_\", rep(measure_labels, n_conds))\n  step_2 <- step_1 |>\n    rapply(as.vector, how = \"list\") |>\n    rbind_list()\n  colnames(step_2) <- c_lbl\n  step_2 |>\n    matcols2lists(group_by = n_measures)\n}\n\ncombine_sims <- function(sim_list) {\n  n_conds <- nrow(sim_list[[1]])\n  n_sims <- length(sim_list)\n  sim_df <- rbind_list(sim_list)\n  sim_df[[\"simulation\"]]  <- paste0(\"simulation_\", rep(1:n_sims, each = n_conds))\n  sim_df[[\"condition\"]] <- paste0(\"condition_\", rep(1:n_conds, times = n_sims))\n  sim_df\n}\n\n# --- Statistical Functions --- # \n\ncorrelation2covariance <- function(cor_mat, sd_var = 50) {\n  sweep(sweep(cor_mat, 1L, sd_var, \"*\"), 2L, sd_var, \"*\")  \n}\n\ncalc_cov_mat <- function(rho, std_dev, ncond = 2) {\n  corr_matrix <- matrix(rep(rho, times = ncond^2), ncol = ncond)\n  diag(corr_matrix) <- 1\n  cov_matrix <- correlation2covariance(cor_mat = corr_matrix, sd_var = std_dev)\n  cov_matrix\n}\n\nfast_t <- function(data_matrix) {\n  diff <- data_matrix[, 1] - data_matrix[, 2]\n  n <- length(diff)\n  deg_fre <- n - 1\n  sd_diff <- sd(diff)\n  se_diff <- sd_diff / sqrt(n)\n  mean_diff <- mean(diff)\n  t_val <- mean_diff / se_diff\n  t_crit <- qt(.975, df = deg_fre)\n  conf.int <- c(mean_diff - (t_crit * se_diff), mean_diff + (t_crit * se_diff))\n  p_val <- pt(-abs(t_val), df = deg_fre, lower.tail = TRUE) * 2 # change this for one-tail\n  list(statistic = t_val, parameter = deg_fre, p.value = p_val, conf.int = conf.int, \n       estimate = mean_diff, stderr = se_diff)\n}\n\nt_test_paired_data <- function(paired_data, fast = TRUE, use_names = TRUE,\n                               info_out = c(\"estimate\", \"statistic\", \"p.value\")) {\n  if (fast) {\n    test_result <- fast_t(paired_data)[info_out] |>\n      unlist()\n  } else {\n    test_result <- t.test(paired_data[, 1], paired_data[, 2], paired = TRUE)[info_out] |>\n      unlist()\n  }\n  if(use_names) {\n    true_means <- as.numeric(sub(\"C[0-9]+_\", \"\", colnames(paired_data)))\n    true_es <- true_means[1] - true_means[2]\n    test_result <- c(true_es, test_result)\n  } else {\n    test_result <- c(NA, test_result)\n  }\n  names(test_result) <- c(\"true_es\", \"estimate\", \"statistic\", \"p.value\")\n  test_result\n}\n\ntest_2x2_paired_data <- function(sim_results,rename_cols = TRUE) {\n  main1 <- t_test_paired_data(sim_results[, 1:2])\n  main2 <- t_test_paired_data(sim_results[, 3:4])\n  diff1 <- sim_results[, 1] - sim_results[, 2]\n  diff2 <- sim_results[, 3] - sim_results[, 4]\n  diff_diff <- cbind(diff1, diff2)\n  diff_es <- c(main1[\"true_es\"], main2[\"true_es\"])\n  colnames(diff_diff) <- paste0(\"C\", seq(diff_es), \"_\", diff_es)\n  interaction <- t_test_paired_data(diff_diff)\n  output <-  rbind(main1, main2, interaction) |>\n    transform(p.adjust = p.adjust(p.value, \"holm\"))\n  output[[\"condition\"]] <- rownames(output)\n  output\n}\n\ncalc_error_design <- function(sim_results, alpha = .05, rename_cols = TRUE) {\n  stopifnot(rename_cols)\n  col_labels <- colnames(sim_results)\n  colnames(sim_results) <- sub(\"cond[0-9]+_\", \"\", col_labels)\n\n  sig_subset_unadjusted <- subset(as.data.frame(sim_results), p.value < alpha)\n  sig_subset_adjusted <- subset(as.data.frame(sim_results), p.adjust < alpha)\n  sim_true_es <- mean(sig_subset_unadjusted$true_es)\n  nsim <- nrow(sim_results)\n  nsig_unadjusted <- nrow(sig_subset_unadjusted)\n  nsig_adjusted <- nrow(sig_subset_adjusted)\n  power_unadjusted <- nsig_unadjusted / nsim\n  power_adjusted <- nsig_adjusted / nsim\n  type_s_unadjusted <- nrow(subset(sig_subset_unadjusted, estimate < 0)) / nsig_unadjusted\n  type_s_adjusted <- nrow(subset(sig_subset_adjusted, estimate < 0)) / nsig_adjusted\n  exaggeration_ratio_unadjusted <- with(sig_subset_unadjusted, \n                                        mean(abs(estimate)) / mean(true_es))\n  exaggeration_ratio_adjusted <- with(sig_subset_adjusted, \n                                      mean(abs(estimate)) / mean(true_es))\n  errors <- c(ES = sim_true_es,\n              power_unadjusted = power_unadjusted,\n              type_s_unadjusted = type_s_unadjusted,\n              exaggeration_ratio_unadjusted = exaggeration_ratio_unadjusted,\n              power_adjusted = power_adjusted,\n              type_s_adjusted = type_s_adjusted,\n              exaggeration_ratio_adjusted = exaggeration_ratio_adjusted)\n  errors\n}\n\n# --- Simulation Functions --- #\n\nsimulate_data_from_es <- function(es, base_mu = 600) {\n  function(rho, std_dev, nsubj) {\n    condition_means <- as.vector(es + base_mu)\n    list(rho, std_dev)\n    cov_mat <- calc_cov_mat(rho, std_dev, ncond = length(es))  # one rho all conds\n    #cov_mat\n    simulation <- MASS::mvrnorm(n = nsubj, mu = condition_means, Sigma = cov_mat,\n                                empirical = FALSE)\n    colnames(simulation) <- paste0(\"C\", seq(condition_means), \"_\", condition_means)\n    simulation\n  }\n}\n\ndo_sim <- function(sim_params, sim_func, Nsim = 5000, alpha = 0.05){\n  replicate(Nsim, do.call(sim_func, sim_params), simplify = FALSE) |>\n    lapply(FUN = matcols2lists, group_by = 2) |>\n    rapply(t_test_paired_data, how = \"list\") |>\n    lapply(FUN = rbind_list) |>\n    lapply(FUN = transform, p.adjust = p.adjust(p.value, \"holm\")) |>\n    organize_output() |>\n    lapply(FUN = calc_error_design, alpha = alpha) |>\n    rbind_list() |>\n    data.frame(sim_params)\n}\n\ndo_sim_2x2 <- function(sim_params, sim_func, Nsim = 5000, alpha = 0.05) {\n  replicate(Nsim, do.call(sim_func, sim_params), simplify = FALSE) |>\n    lapply(FUN = matcols2lists, group_by = 4) |>\n    rapply(test_2x2_paired_data, how = \"list\" )  |>\n    unlist(recursive = FALSE) |>\n    rbind_list() |>\n    split(~condition) |>\n    lapply(FUN = calc_error_design, alpha = alpha) |>\n    rbind_list() |>\n    data.frame(sim_params)\n}\n```\n:::\n\n\n\n\n# Simulating possible scenarios for the Frequency Attenuation effect in Masked Priming\n\nSeventeen studies were found in the literature about frequency attenuation. Out of these:\n\n-   All show the repetition effect for both HF and LF words.\n\n-   Only three show a statistically significant interaction between identity priming and frequency (with lower frequency words showing more masked id priming). The effect sizes on these three are quite large (30, 31 and 32 ms), about as large as the corresponding masked id priming for HF in the experiment.\n\nThus, it seems reasonable that there may be a frequency attenuation effect, but what is its actual size? The experiments that detected it found a very large one, but this seems a rare event: if the effect size really is that large, why aren't we finding the interaction as often as the main effects? The inconsistency of past findings regarding the FAE in masked priming has been linked to a potential lack of statistical power in previous research [@BodnerMasson1997; @BodnerMasson2001; @MassonBodner2003; @Adelman2014]. This is a reasonable concern, as interactions like the FAE often require larger sample sizes for statistical detection [@PotvinSchtuz2000; @BrysbaertStevens2018] compared to main effects.\n\nWe ran an extensive power analysis to determined the sample size large enough to guarantee an acceptable statistical power ($>80%$) able to detect what we construed as the smallest theoretically interesting FAE (i.e., 5ms). To this end, the code below simulates 10,000 datasets for each of the combinations of the following parameters:\n\n  1. Standard deviation and correlation between related and unrelated condition. Based on our own pilot studies and previous published work [@Petrosino2020; @PetrosinoEtal2023], the simulations involved standard deviations ranging from 80 to 120 ms (with 10 ms increments), while the correlation between conditions ranged from 0.7 to 0.9 (with 0.1 increments). T\n  2. Sample size, ranging between 200 and 3000 participants (with 150-participant increments)\n  3. Three FAE sizes were simulated: 15 ms, 10 ms and 5 ms. The first effect size (15 ms) is about half of the ones observed in previous studies that statistically detected the FAE (~30 ms). The second effect size (10 ms) is close to the size of the average frequency attenuation effect found in the literature (13 ms). The last effect size (5 ms) is our lower-bound estimate of a theoretically interesting effect size. \n  \n### ES = 5 ms\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| eval: false\n#| cache: true\n\n## Simulation of simple effects: Using a matrix of possible parameters\nfreq_atten_sim.5ms_Nsim <- 10000\n\n# ---- range of Effect Sizes ------#\n# ---- range of DD Effect Sizes ------#\nfreq_atten_sim.5ms_base_es <- 60\nfreq_atten_sim.5ms_dd_to_sim <- freq_atten_sim.5ms_base_es - c(30, 25) # this will create the 2x2 design in which each pair will represent the unrelated and related level of each condition (e.g., high and low frequency). So the two values in the second term of the difference are the actual priming effects of the two conditions of the 2x2 factorial design. These priming effects will be analyzed in a paired t-test in each of the 10,000 simulations of each combination of sample size, sd, and rho. \n\n# ---- design ----#\nfreq_atten_sim.5ms_design <- expand.grid(freq_atten_sim.5ms_base_es, freq_atten_sim.5ms_dd_to_sim) |>\n  t() |>\n  as.vector() |>\n  setNames(paste0(\"ES\", 1:(length(freq_atten_sim.5ms_dd_to_sim)*2)))\n\n# ---- range of N ------#\nfreq_atten_sim.5ms_n_subjs_to_sim <- seq(200, 3000, by = 150)\n\n# ---- range of SDs ------#\nfreq_atten_sim.5ms_min_sd <- 60\nfreq_atten_sim.5ms_max_sd <- 180\nfreq_atten_sim.5ms_sd_increment <- 10\nfreq_atten_sim.5ms_sds_to_sim <- seq(from = freq_atten_sim.5ms_min_sd, to = freq_atten_sim.5ms_max_sd, \n                                by = freq_atten_sim.5ms_sd_increment)\n\n# ---- range of rhos ------#\nfreq_atten_sim.5ms_min_rho <- .6\nfreq_atten_sim.5ms_max_rho <- .9\nfreq_atten_sim.5ms_rho_increment <- .1\nfreq_atten_sim.5ms_rhos_to_sim <- seq(from = freq_atten_sim.5ms_min_rho, to = freq_atten_sim.5ms_max_rho, \n                                 by = freq_atten_sim.5ms_rho_increment)\n\n# ---- create the control matrix ---- #\nfreq_atten_sim.5ms_simulation_params <- expand.grid(freq_atten_sim.5ms_rhos_to_sim,\n                                               freq_atten_sim.5ms_sds_to_sim,\n                                               freq_atten_sim.5ms_n_subjs_to_sim)\ncolnames(freq_atten_sim.5ms_simulation_params) <- c(\"rho\", \"std_dev\", \"nsubj\")\nfreq_atten_sim.5ms_simulate_effects <- simulate_data_from_es(freq_atten_sim.5ms_design)\nfreq_atten_sim.5ms_params <- freq_atten_sim.5ms_simulation_params |>\n  split(seq(nrow(freq_atten_sim.5ms_simulation_params))) |>\n  lapply(FUN = as.list)\n\n### Run simulation\nset.seed(20140715)\nt0 <- Sys.time()\nfreq_atten_sim.5ms_df <- lapply(freq_atten_sim.5ms_params, do_sim_2x2, \n                               freq_atten_sim.5ms_simulate_effects, \n                               Nsim = freq_atten_sim.5ms_Nsim) |>\n  combine_sims()\nSys.time() - t0\nsave(\"freq_atten_sim.5ms_df\", file = \"freq_atten_sim.5ms.RData\", compress=TRUE)\n\nload(\"freq_atten_sim.5ms.RData\")\n\n## Plotting\nfreq_atten_sim.5ms_df |>\n  subset(ES == 5) |>\n  ggplot(aes(x = nsubj, y = power_unadjusted)) + \n    geom_line(aes()) + \n    geom_point() +\n    geom_hline(yintercept = c(0.8, 0.5, 0.1), color = \"red2\") + \n    facet_grid(rho ~ std_dev) \n```\n:::\n\n\n\n\n### ES = 10 ms\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| cache: true\n#| eval: false\n\n## Simulation of simple effects: Using a matrix of possible parameters\nfreq_atten_sim.10ms_Nsim <- 10000\n\n# ---- range of Effect Sizes ------#\n# ---- range of DD Effect Sizes ------#\nfreq_atten_sim.10ms_base_es <- 60\nfreq_atten_sim.10ms_dd_to_sim <- freq_atten_sim.10ms_base_es - c(30, 20) # this will create the 2x2 design in which each pair will represent the unrelated and related level of each condition (e.g., high and low frequency). So the two values in the second term of the difference are the actual priming effects of the two conditions of the 2x2 factorial design. These priming effects will be analyzed in a paired t-test in each of the 10,000 simulations of each combination of sample size, sd, and rho. \n\n# ---- design ----#\nfreq_atten_sim.10ms_design <- expand.grid(freq_atten_sim.10ms_base_es, freq_atten_sim.10ms_dd_to_sim) |>\n  t() |>\n  as.vector() |>\n  setNames(paste0(\"ES\", 1:(length(freq_atten_sim.10ms_dd_to_sim)*2)))\n\n# ---- range of N ------#\nfreq_atten_sim.10ms_n_subjs_to_sim <- seq(200, 3000, by = 150)\n\n# ---- range of SDs ------#\nfreq_atten_sim.10ms_min_sd <- 60\nfreq_atten_sim.10ms_max_sd <- 180\nfreq_atten_sim.10ms_sd_increment <- 10\nfreq_atten_sim.10ms_sds_to_sim <- seq(from = freq_atten_sim.10ms_min_sd, to = freq_atten_sim.10ms_max_sd, \n                                by = freq_atten_sim.10ms_sd_increment)\n\n# ---- range of rhos ------#\nfreq_atten_sim.10ms_min_rho <- .6\nfreq_atten_sim.10ms_max_rho <- .9\nfreq_atten_sim.10ms_rho_increment <- .1\nfreq_atten_sim.10ms_rhos_to_sim <- seq(from = freq_atten_sim.10ms_min_rho, to = freq_atten_sim.10ms_max_rho, \n                                 by = freq_atten_sim.10ms_rho_increment)\n\n# ---- create the control matrix ---- #\nfreq_atten_sim.10ms_simulation_params <- expand.grid(freq_atten_sim.10ms_rhos_to_sim,\n                                               freq_atten_sim.10ms_sds_to_sim,\n                                               freq_atten_sim.10ms_n_subjs_to_sim)\ncolnames(freq_atten_sim.10ms_simulation_params) <- c(\"rho\", \"std_dev\", \"nsubj\")\nfreq_atten_sim.10ms_simulate_effects <- simulate_data_from_es(freq_atten_sim.10ms_design)\nfreq_atten_sim.10ms_params <- freq_atten_sim.10ms_simulation_params |>\n  split(seq(nrow(freq_atten_sim.10ms_simulation_params))) |>\n  lapply(FUN = as.list)\n\n### Run simulation\nset.seed(20140715)\nt0 <- Sys.time()\nfreq_atten_sim.10ms_df <- lapply(freq_atten_sim.10ms_params, do_sim_2x2, \n                               freq_atten_sim.10ms_simulate_effects, \n                               Nsim = freq_atten_sim.10ms_Nsim) |>\n  combine_sims()\nSys.time() - t0\nsave(\"freq_atten_sim.10ms_df\", file = \"freq_atten_sim.10ms.RData\", compress=TRUE)\n\n\nload(\"freq_atten_sim.10ms.RData\")\n\n## Plotting\nfreq_atten_sim.10ms_df |>\n  subset(ES == 10) |>\n  ggplot(aes(x = nsubj, y = power_unadjusted)) + \n    geom_line(aes()) + \n    geom_point() +\n    geom_hline(yintercept = c(0.8, 0.5, 0.1), color = \"red2\") + \n    facet_grid(rho ~ std_dev) \n```\n:::\n\n\n\n\n### ES = 15 ms\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| cache: true\n#| eval: false\n\n## Simulation of simple effects: Using a matrix of possible parameters\nfreq_atten_sim.15ms_Nsim <- 10000\n\n# ---- range of Effect Sizes ------#\n# ---- range of DD Effect Sizes ------#\nfreq_atten_sim.15ms_base_es <- 60\nfreq_atten_sim.15ms_dd_to_sim <- freq_atten_sim.15ms_base_es - c(30, 15) # this will create the 2x2 design in which each pair will represent the unrelated and related level of each condition (e.g., high and low frequency). So the two values in the second term of the difference are the actual priming effects of the two conditions of the 2x2 factorial design. These priming effects will be analyzed in a paired t-test in each of the 10,000 simulations of each combination of sample size, sd, and rho. \n\n# ---- design ----#\nfreq_atten_sim.15ms_design <- expand.grid(freq_atten_sim.15ms_base_es, freq_atten_sim.15ms_dd_to_sim) |>\n  t() |>\n  as.vector() |>\n  setNames(paste0(\"ES\", 1:(length(freq_atten_sim.15ms_dd_to_sim)*2)))\n\n# ---- range of N ------#\nfreq_atten_sim.15ms_n_subjs_to_sim <- seq(200, 3000, by = 150)\n\n# ---- range of SDs ------#\nfreq_atten_sim.15ms_min_sd <- 60\nfreq_atten_sim.15ms_max_sd <- 180\nfreq_atten_sim.15ms_sd_increment <- 10\nfreq_atten_sim.15ms_sds_to_sim <- seq(from = freq_atten_sim.15ms_min_sd, to = freq_atten_sim.15ms_max_sd, \n                                by = freq_atten_sim.15ms_sd_increment)\n\n# ---- range of rhos ------#\nfreq_atten_sim.15ms_min_rho <- .6\nfreq_atten_sim.15ms_max_rho <- .9\nfreq_atten_sim.15ms_rho_increment <- .1\nfreq_atten_sim.15ms_rhos_to_sim <- seq(from = freq_atten_sim.15ms_min_rho, to = freq_atten_sim.15ms_max_rho, \n                                 by = freq_atten_sim.15ms_rho_increment)\n\n# ---- create the control matrix ---- #\nfreq_atten_sim.15ms_simulation_params <- expand.grid(freq_atten_sim.15ms_rhos_to_sim,\n                                               freq_atten_sim.15ms_sds_to_sim,\n                                               freq_atten_sim.15ms_n_subjs_to_sim)\ncolnames(freq_atten_sim.15ms_simulation_params) <- c(\"rho\", \"std_dev\", \"nsubj\")\nfreq_atten_sim.15ms_simulate_effects <- simulate_data_from_es(freq_atten_sim.15ms_design)\nfreq_atten_sim.15ms_params <- freq_atten_sim.15ms_simulation_params |>\n  split(seq(nrow(freq_atten_sim.15ms_simulation_params))) |>\n  lapply(FUN = as.list)\n\n### Run simulation\nset.seed(20140715)\nt0 <- Sys.time()\nfreq_atten_sim.15ms_df <- lapply(freq_atten_sim.15ms_params, do_sim_2x2, \n                               freq_atten_sim.15ms_simulate_effects, \n                               Nsim = freq_atten_sim.15ms_Nsim) |>\n  combine_sims()\nSys.time() - t0\nsave(\"freq_atten_sim.15ms_df\", file = \"freq_atten_sim.15ms.RData\", compress=TRUE)\n\n\nload(\"freq_atten_sim.15ms.RData\")\n\n## Plotting\nfreq_atten_sim.15ms_df |>\n  subset(ES == 15) |>\n  ggplot(aes(x = nsubj, y = power_unadjusted)) + \n    geom_line(aes()) + \n    geom_point() +\n    geom_hline(yintercept = c(0.8, 0.5, 0.1), color = \"red2\") + \n    facet_grid(rho ~ std_dev) \n```\n:::\n\n\n\n\n# Conclusions\n\nOur analysis identified a sample size of 1,250 participants as optimal, ensuring robust statistical power (> 80%) across various parameter combinations (@fig-power-1250), especially for raw FAEs equal to or exceeding 10 ms —- a value closely aligned with the average FAE calculated from previous studies (see Introduction in the paper). In light of the limitations in the temporal accuracy and precision of current online stimulus delivery programs (observed in several pilots and previous published studies conducted in our lab), we aimed for an intended sample size of 2,600. This decision was made to enhance the likelihood of obtaining a sample size of at least 1,250 participants after applying all the necessary exclusion criteria to the data. In addition, sample sizes exceeding 1,250 can only help increase the precision of the estimated effect size.\n\n\n\n\n::: {#cell-fig-power-1250 .cell}\n\n```{.r .cell-code .hidden}\n#| label: fig-power-1250\n#| fig-cap: \"Power simulations with a sample size of 1,250, for all combinations of standard deviation (sd), pairwise correlation (cor), and interaction effect size. The red line identifies the threshold of 80% power.\"\n\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\n#| label: fig-power-1250\n#| fig-cap: \"Power simulations with a sample size of 1,250, for all combinations of standard deviation (sd), pairwise correlation (cor), and interaction effect size. The red line identifies the threshold of 80% power.\"\n\nload('../supplemental-data/freq_atten_sim.5ms.RData') # ES = 5 ms\nload('../supplemental-data/freq_atten_sim.10ms.RData') # ES = 10 ms\nload('../supplemental-data/freq_atten_sim.15ms.RData') # ES = 15 ms\n\nfreq_atten_sim.5ms_df.sub <- freq_atten_exp2.5ms_df %>% \n  filter(ES == 5) %>%\n  filter(std_dev >= 80 & std_dev <= 120) %>%\n  filter(rho >= 0.7 & rho <= 0.9)\n\nfreq_atten_sim.10ms_df.sub <- freq_atten_exp2.10ms_df %>% \n  filter(ES == 10) %>%\n  filter(std_dev >= 80 & std_dev <= 120) %>%\n  filter(rho >= 0.7 & rho <= 0.9)\n\nfreq_atten_sim.15ms_df.sub <- freq_atten_exp2.15ms_df %>% \n  filter(ES == 15 & grepl(\"interaction\", row.names(freq_atten_exp2.15ms_df))) %>%\n  filter(std_dev >= 80 & std_dev <= 120) %>%\n  filter(rho >= 0.7 & rho <= 0.9)\n\npower_pred_df <- bind_rows(freq_atten_sim.5ms_df.sub, freq_atten_sim.10ms_df.sub, freq_atten_sim.15ms_df.sub) \n\npower_pred_df.sub1250 <- power_pred_df %>%\n  filter(nsubj == 1250)\n\npower_pred_df.sub1250 |>\n  ggplot(aes(y = power_unadjusted, x = ES)) + \n    geom_line() + \n    geom_point() +\n    geom_hline(yintercept = 0.8, color = \"red2\") + \n    facet_grid(rho ~ std_dev) +\n  scale_x_continuous(breaks=seq(5, 15, 5), limits=c(5, 15), labels=seq(5, 15, 5),\n    sec.axis = sec_axis(~ . , name = \"sd\", breaks = NULL, labels = NULL)) +\n  scale_y_continuous(breaks=seq(0, 1, 0.2), limits=c(0, 1), labels=seq(0, 1, .2),\n    sec.axis = sec_axis(~ . , name = \"cor\", breaks = NULL, labels = NULL)) +\n  theme_bw()+\n    theme(#axis.line = element_line(colour = \"black\"),\n      panel.grid.major = element_blank(),\n      panel.grid.minor = element_blank(), \n      panel.border = element_blank(),\n      legend.position=\"none\"\n      #panel.background = element_blank() \n     )+\n  labs(title=\"N=1,250\", y = \"power (unadjusted)\", x = \"FAE size (ms)\")\n```\n\n::: {.cell-output-display}\n![Power simulations with a sample size of 1,250, for all combinations of standard deviation (sd), pairwise correlation (cor), and interaction effect size. The red line identifies the threshold of 80% power.](power-analysis-sims_files/figure-html/fig-power-1250-1.png){#fig-power-1250 width=672}\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}